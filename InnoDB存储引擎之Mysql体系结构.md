---
   title: InnoDB存储引擎
   date: 2019-05-13 11:49:00
   tags: 读书笔记
---
无论计算机技术的发展速度有多快，数据库的使用变得多简单，任何时候Why都比What重要。只有真正理解了内部实现原理、体系结构，才能更好地去使用。因此对于当前出现的技术，尽管学习应用很重要，但更重要的是，应当正确的理解和使用这些技术。

关于书本，有几个重要的观点：
- 不要相信“神话”，学会自己思考；
- 不墨守成规，大部分人知道的事情可能是错误的；
- 不要相信网上的传言，根据时间做出决定；
- 花时间充分思考，敢于提出质疑。

---摘自作者序
<!-- more -->
今天开始重新阅读《MySQL技术内幕-InnoDB存储引擎》这本书，记录一下阅读过程中的关键知识点。
## 第一章节MySQL体系结构和存储引擎
MySQL体系架构图。
![](http://pic.evilhex.com/2019-05-13-15577216874159.jpg)
MySQL由以下几部分组成：
- 连接池组件
- 管理服务和工具组件
- SQL接口组件
- 查询分析器组件
- 优化器组件
- 缓冲组件
- 插件式存储引擎(存储引擎是基于表的，而非数据库，是底层物理结构的实现)
- 物理文件

### InnoDB存储引擎
InnoDB支持事务，其设计目标是面向在线事务处理的应用。特点是行锁设计、支持外键，并支持类似Oracle的非锁定读，即默认读取操作不会产生锁。

InnoDB通过使用多版本并发控制(MVCC)来获得高并发性，并且实现了SQL标准的4中隔离级别，默认REPEATABLE级别。同时，使用一种被称为next-key-locking的策略来避免幻读现象的产生。初次之外，InnoDB存储引擎还提供了插入缓冲（insert buffer）、二次写（double write）、自适应哈希索引（adaptive hash）、预读（read ahead）等高性能和高可用的功能。

对于表中数据的存储，InnoDB存储引擎采用了聚集（clustered）的方式，因此每张表的存储都是按照主键的顺序进行存放。如果没有显示地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此作为主键。

### 连接MySQL
连接MySQL操作是一个连接进程和MySQL数据库实例进行通信。从程序设计的角度来说，本质上是进程通信。常用的进程间通信方式有管道、命名管道、命名字、TCP/IP套接字、UNIX域套接字。MySQL数据库提供的连接方式从本质上看都是上述提及的进程通信方式。
## 第二章 InnoDB存储引擎
### InnoDB存储引擎体系架构
![InnoDB存储引擎架构](http://pic.evilhex.com/2019-05-13-InnoDB存储引擎架构.jpg)

InnoDB存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池，维护所有进程/线程需要访问的多个内部数据结构，缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存，重做日志缓冲。

#### 后台线程
后台线程的作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存时最近的数据。此外，将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态。

InnoDB存储引擎是多线程的模型，因此其后台具有多个不同的后台线程，负责处理不同的任务。

Master Thread：Master Thread是一个非常可信的后台线程，主要负责将缓冲池中数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO页的回收。

IO Thread：在InnoDB存储引擎中大量使用了AIO来处理IO请求，这样可以极大提高数据库的性能。
 
Purge Thread：事务被提交后，其所使用的undolog可能不再需要，Purge Thread用来回收已经使用并分配的undo页。

### 内存
##### 缓冲池
InnoDB是基于磁盘存储的，在数据库系统中由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。
缓冲池简单来说是一块内存区域，通过内存的速度来弥补磁盘速度对数据库性能的影响。在数据中进行读取页的操作，首先将磁盘读取的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中。下一次读相同的页时，首先判断该页是否在缓冲池中。若在，则称改页在缓冲池中被命中，直接读取改页。否则，读取磁盘上的页。

对于数据库中页的修改，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。

> 页从缓冲池刷新到磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为CheckPoint的机制刷新回磁盘。

缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。

> 不能简单的认为，缓冲池只是缓存索引页和数据页，它们只是占缓冲池很大一部分而已。

InnoDB内存数据对象如下所示。
![InnoDB内存数据对象](http://pic.evilhex.com/2019-05-13-InnoDB内存数据对象.jpg)
##### LRU List、Free List和Flush List
InnoDB是怎么对这么大的内存区域进行管理的呢？通常来说，数据库中的缓冲池是通过LRU算法来进行管理的。在InnoDB存储引擎中，缓冲池中也的大小默认是16KB，同样使用LRU算法对缓冲池进行管理。
但是，InnoDB存储引擎对传统的LRU算法做了一些优化，在LRU列表中还加入了midpoint位置。新读取到的页，虽然是新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置。默认情况下，改位置在LRU列表的5/8处。

> 为什么不采用朴素的LRU算法，直接把读取的也放到LRU列表的首部呢?如果这样做的话，某些SQL操作可能会使缓冲池中的页被刷出，从而能影响缓冲池的效率。例如，索引或者数据的扫描操作会访问表中的许多页，甚至是全部的页。而这些页通常来说仅仅在这次查询操作中需要，并不是活跃的热点数据。如果放到首部，非常可能将所需要的热点数据页从LRU列表中移除。

##### 其他缓冲池
重做日志缓冲：InnoDB存储引擎先将重做日志信息放到缓冲池中，然后按一定的频率将其刷新到重做日志文件。以下三种情况会把重做日志缓冲刷新到重做日志文件：
- Master Thread每秒将重做日志缓冲刷新到重做日志文件中；
- 每个事务提交时会将重做日志缓冲刷新到重做日志文件；
- 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。

### Checkpoint技术
为了避免数据丢失的问题，当前事务数据库系统普遍都采用了Write Ahead log策略，即当事务提交时，先写重做日志，再修改页。当由于发生宕机导致数据丢失时，通过重做日志来完成数据的恢复，这也是事务ACID中D的要求。

Checkpoint(检查点)技术的目的是解决了一下几个问题：
- 缩短数据库的恢复时间；
- 缓冲池不够用时，将脏页刷新到磁盘；
- 重做日志不可用时，刷新脏页；

当数据库发生宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘。故数据库只需要对Checkpoint后的重做日志进行恢复，这样就大大缩短了恢复的时间。

### InnoDB关键特性
InnoDB存储引擎的关键特性包括：
- 插入缓冲
- 两次写
- 自适应哈希索引
- 异步IO
- 刷新邻接页

#### 插入缓冲
Insert Buffer可能是InnoDB存储引擎关键特性中最令人激动与兴奋的一个功能。通常应用程序中行记录的插入顺序是按照主键递增的顺序进行插入的。因此，插入聚集索引一般是顺序的，不需要按照磁盘的随机读取。
> 并不是所有的主键插入都是顺序的。若主键类是UUID这样的类，那么插入和辅助索引是一样的，同样都是随机的。即使主键是自增类型，但是插入的是指定的值，而不是NULL值，那么同样可能导致插入并非连续的情况。

但是不可能每一张表上只有一个聚集索引，更多情况下，一张表上有多个非聚集的辅助索引。对于非聚集索引叶子节点的插入如果不是顺序插入，就需要离散地访问非聚集索引页，由于随机读取的存在而导致了插入操作的性能下降。B+树的特性决定了非聚集索引插入的离散型。InnoDB存储引擎开创性地设计了Insert Buffer，对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，好似欺骗。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge操作。

Insert Buffer的使用需要同时满足以下两个条件：
- 索引是辅助索引
- 索引不是唯一的

#### 二次写

如果说Insert Buffer带给InnoDB存储引擎的是性能上的提升，那么doublewrite带给InnoDB存储引擎的是数据页的可靠性。当发生数据库宕机时，可能InnoDB存储引擎正在写入某个页到表中，而这个页只写入了一部分，比如16KB的页，只写了4KB，之后就发生了宕机，这种情况被称为部分写失效。

有经验的DBA会通过重做日志进行恢复，但是重做日志中记录的是对页的物理操作。如果这个页本身已经发生损坏，再对其进行重做是没有意义的。也就是说，在应用重做日志前，用户需要维护一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。

#### 自适应哈希索引
哈希是一种非常快的查找方法，在一般情况下这种查找的时间复杂度为O(1)，即一般仅需要一次查找就能定位数据。而B+树的查找次数取决于B+树的高度，在生产环境中，B+树的高度一般为3到4层，故需要3~4次的查询。

InnoDB存储引擎会监控对表上各索引页的查询。如果观察到简历哈希索引可以带来速度提升，则简历哈希索引，称之为自适应哈希索引(Adaptive Hash Index,AHI)。AHI是通过缓冲池中B+树页来构造的，因此建立速度很快，而且不需要对整张表简历哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。

#### 异步IO
为了提高磁盘操作性能，当前的数据库系统都采用异步IO的方式来处理磁盘操作。用户可以在发出一个IO请求之后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，这就是AIO。
AIO的另一个优势是可以进行IO merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能。
#### 刷新邻接页
InnoDB存储引擎还提供了Flush Neighbor Page的特性。工作原理是：当刷新一个脏页时，InnoDB存储引擎会检测该页所在的区的所有页，如果是脏页，那么一起进行刷新。


