---
   title: 《码出高效》一书知识点整理
   date: 2019-1-29 15:19:00
   tags:  java
---

这本书真的是称得上由浅入深，老少皆宜。书中对于那些看似浅薄的知识点的剖析准确到位，便于理解，有的地方甚至解开了我一直以来的困惑。将书本中的知识点整理总结，方便后续回顾和深入思考。

### 计算机基础

生活就是这样，有些简简单单的道理需要经过磕磕碰碰才能有更好的领悟。

开篇作者提到一个观点，基础知识的深度认知决定着知识上层建筑的延展性。仔细一想，确实如此，我们总是忙于学习高并发，高可用看似牛逼的东西，却忽略问题的本质，不仅折本求末，而且严重限制格局。

比如，文中提到的几个问题：

- 位移运算可以快速实现乘除运算，那位移运算需要注意什么？
- 浮点数的存储与计算为什么总产生微小的误差？
- 乱码产生的根源是什么？
- 代码执行时，CPU是如何与内存配合完成程序执行的？
- 网络连接资源耗尽的本质是什么?
- 黑客攻击的套路是什么？如何有效的防止？
<!-- more -->
这些问题，涵盖了计算机网络，组原，信安的知识，作为一个有两年编程经验的老司机，不好好想想，还真是不能回答的很全面。

书中有意思的内容：字符集与乱码这一块，《深入分析java web》讲的更透彻一些。TCP,IP这一块需要关注SYN,ACK,FIN。三次握手的目的：信息对等和防止超时。TCP IP 的状态转换跟操作系统底层的性能调优密不可分。HTTPS的完整过程。

### java部分

#### 面向对象
在JDK源码中，使用内部类封装某种属性和操作的方式比较常见，比如类加载器Launcher的AppClassLoader，ReentrantLock中继承自AQS的Sync,ArrayList中的私有静态内部类SubList。内部类中还可以定义内部类，形成多层嵌套，如在ThreadLocal静态内部类ThreadLocalMap中还定义一个内部类Entry。其实这些源码，都是很有意思的，花时间去看看，如果能体会到作者的设计意图，会有很大的收获。

方法签名包括方法名称和参数列表，是JVM标识方法的唯一索引，不包括返回值，更不包括权限控制符和异常类型等。

实参与形参的区别。正确的使用方法：入参保护和参数校验。

构造方法的使命是在构造对象时进行传参操作，所以不应该在构造方法中进行引入业务逻辑。业务逻辑的处理可以放在单独的方法中，比如init()中。在实际应用中例如容器初始化时，可以使用静态代码块实现类加载判断、属性初始化、环境配置等。

#### 类加载的过程

加载，链接，初始化

加载：读取类文件产生二进制流，并转化为特定的数据接口，进行初步校验，创建对应类的java.lang.Class实例。

链接：验证，更详细的校验；准备，为静态变量分配内存，设置默认值；解析，确保类与类之间的相互引用正确性，完成内存结构布局。

初始化：执行类构造器<clinit>方法。

类加载器：第一层，BootStrap是最根本的类加载器，负责加载最核心的java类，Object，System，String等；第二层，JDK9中称为平台类加载器，加载一些扩展的系统类，如XML，加密，压缩相关的功能类；第三层，是应用类加载器，加载用户自定义的CLASSPATH路径下的类。二三层为java语言实现，用户也可以自定义。

#### 内存布局

线上环境，JVM的Xms和Xmx设置成一样的大小，避免GC后调整堆大小时带来的额外压力。

堆：新生代（1个Eden区+2个Survivor区）+老年代

绝大部分对象在Eden区生成，Eden填满会出发Yong Garbage Collection。

新申请对象，如果在Survivor区无法放下，或者超大对象的阈值超过上限，就尝试在老年代中进行分配；如果老年代中也放不下，就会出发Full Garbage Collection。如果依然放不下，就抛出OOM。

JDK8中，元空间的前身Perm区已经被淘汰。区别于永久代，元空间在本地内存中分配。Perm区中的所有内容字符串常量被移动到堆内存，其他字段包括类元信息，字段，静态属性，方法，常量等都移动到元空间。

GC roots：类静态属性中引用的对象，常量引用的对象，虚拟机栈和本地方法栈中引用的对象。

创建一个对象的完整过程，能不能详细的说出来？
           
### 数据结构与集合

[这里似乎讲的很透彻](https://www.jianshu.com/p/c0642afe03e0)

红黑树：父红子黑，一路黑同，首尾一般黑，中间可红可黑

ConcurrentHashmap的实现机制，1.8和1.7的区别，CAS在这里边的作用。

###  java并发

Unsafe可以直接操作Java内存（直接内存，内存回收需要手动进行），通过allocateInstance()方法，你可以创建一个类的实例，但是却不需要调用它的构造函数、初使化代码、各种JVM安全检查以及其它的一些底层的东西。即使构造函数是私有，我们也可以通过这个方法创建它的实例。

LockSupport是JDK中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞原语。AQS就是通过调用LockSupport .park()和 LockSupport .unpark()实现线程的阻塞和唤醒的。


[AQS的讲解比较透彻的](http://tianshouzhi.com/api/tutorials/mutithread/110)

AQS:java构建同步组件的基础，没有弄懂AQS，就没有真正的掌握java并发。同步组件总体上分为独占锁和共享锁，不管是独占还是共享，使用的过程本质上是获取许可和释放许可。而获取和释放关键是对于许可数量的维护以及等待队列的维护。

Condition的作用是替代Object的监视器方法（wait，notify，notifyall），与lock方法配合使用。类似于wait、notify 和 notifyAll必须在同步代码块中使用，Condition对象的方法也必须要写在Lock.lock与Lock.unLock()代码之间。

Semaphore可以控制同时访问的线程个数。

CyclicBarrier可以实现让一组线程等待至某个状态之后再全部同时执行。

#### Lock
ReadWriteLock维护了一对相关的锁，一个用户只读操作，另一个用户写入操作。只要没有writer，读取锁是可以由多个reader线程同时保持。写入锁是独占的。

所有 ReadWriteLock 实现都必须保证 writeLock 操作的内存同步效果也要保持与相关 readLock 的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。

与互斥锁相比，读写锁支持更高级别的并发访问。
